

# 常见错误&结论

​																				C：结论，Q：问题，F：有趣的事儿

## C：如何读取当前类路径下的properties



简单例子

配置sso.properties：

```properties
url="hello world"
```



配置文件的读取：

```java
Properties properties = new Properties();
properties.load(this.getClass().getClassLoader().getResourceAsStream("sso.properties"));
String url = (String) properties.get("url");
System.out.println(url);
```

一定要读取到classLoader里面去，估计与类的运行机制有关





## Q：拦截器不生效的原因

写好的拦截器（实现HandlerInterceptor接口）一定要进行配置，才能起作用

拦截器：

```java
@Component
public class HelloHandler implements HandlerInterceptor {

    /**
     *  true：不拦截
     *  false：拦截在当前中
     */
    @Override
    public boolean preHandle(HttpServletRequest request, HttpServletResponse response, Object handler) throws Exception {
        System.out.println("拦截生效");
        return false;
    }
}
```

配置类：

```java
@Configuration
public class InterruptConfig implements WebMvcConfigurer {

    @Autowired
    HelloHandler helloHandler;

    @Override
    public void addInterceptors(InterceptorRegistry registry) {
        registry.addInterceptor(helloHandler).addPathPatterns("/**");
    }
}
```



## C：Java基本类型所占字节数

​	

|  类型   | 存储需求 |
| :-----: | :------: |
|  short  |    2     |
|   int   |    4     |
|  long   |    8     |
|  byte   |    1     |
|  float  |    4     |
| double  |    8     |
|  char   |    2     |
| boolean |    1     |
|         |          |



## C：JDBC的url书写规范

在MySQL8.0之后都要加上时区信息，否则会报错

```
jdbc:mysql://localhost:3306?serverTimezone=UTC
```



## C；数据库中的命名问题

数据库中命名表最好在后面加个s，避免一些不必要的麻烦，比如订单表order，就和MySQL的关键字冲突





## F：套娃式创建对象

在研究JUC的延迟初始化带来的问题的时候想到的

```java
public class Demo4 {

    Demo4 demo4;

    public static void main(String[] args) {
        Demo4 demo4 = new Demo4();
        System.out.println(ObjectSizeCalculator.getObjectSize(demo4));
    }
}
```

就是输出对象占的字节数，刚开始的时候代码是像上面那样写的，没报错，输出为16，删除成员变量之后输出还是16（对象头4字节，Class对象指针4字节，还有对其填充）

把上面代码修改了下，第三行改成`Demo4 demo4 = new Demo4();`

直接报错：

```java
Exception in thread "main" java.lang.StackOverflowError
	at cn.luckycurve.threadsecurity.Demo4.<init>(Demo4.java:7)
	at cn.luckycurve.threadsecurity.Demo4.<init>(Demo4.java:7)
	at cn.luckycurve.threadsecurity.Demo4.<init>(Demo4.java:7)
```

堆栈溢出错误（还蛮有意思的）

**C：仅仅在类中存在一个引用是不占内存的，初始外围对象的时候不会初始里面的对象，需要你手动去new**





## C：SpringBoot的并发性

SpringBoot默认实现了线程池，我们的异步调用就是通过启动线程池中的线程来完成的，具体体验如下

```java
    @GetMapping("/sleep")
    public String sleep() throws InterruptedException {
        System.out.println(Thread.currentThread().getName()+"：开始执行");
        TimeUnit.SECONDS.sleep(100);
        System.out.println(Thread.currentThread().getName()+"：执行完成");
        return "执行完成";
    }
```

同时开了五个窗口：

```java
http-nio-8080-exec-1：开始执行
http-nio-8080-exec-3：开始执行
http-nio-8080-exec-5：开始执行
http-nio-8080-exec-4：开始执行
http-nio-8080-exec-6：开始执行
http-nio-8080-exec-1：执行完成
http-nio-8080-exec-3：执行完成
http-nio-8080-exec-5：执行完成
http-nio-8080-exec-4：执行完成
http-nio-8080-exec-6：执行完成
```

明显的多线程任务





## C：Java数据传输

只有在基本数据类型和其封装类的是传值，在对象和基本数据类型数组都是传输的地址，所以只有基本数据类型需要get和set方法，对象只需要get方法





## C：谨慎操作数组

操作传入进来的数组默认就是操作原数据（传的是地址）

使用Arrays.copyOf()进行复制操作





## C：final修饰全局变量

final修饰全局变量不仅使得基本数据类型和其封装类无法改变数值，数组和类无法改变引用的对象，还保证了被修饰的变量的全局可见性，因此就有很多结论：

因为保证类的线程安全性只需要保证：1.操作的原子性，2.可见性

所以当类有如下关系，如果此时类B恰好还是线程安全的，则A可以将他的线程安全性交付给B

```java
Class A {
  private final Class B;
}
```

假设是如下的情况：则需要B，C线程安全并且BC之间没有耦合，可以推而广之

:warning:：这里的耦合关系不是指B，C的物理关系，而是逻辑关系，就像我们做缓存的时候用B做Key，C做Value，BC之间会相互依赖，即不满足这种条件

```java
Class A {
  private final Class B;
  private final Class C;
}
```

不用太纠结final变量的性能，final对性能的影响微乎其微，更何况我们编写程序的时候还是要以安全性优先的





## C：Collections工具类

![image-20200401135904632](images/image-20200401135904632.png)

Collections这几个方法可以返回对应集合的“只读”对象，如果强行修改就会爆`java.lang.UnsupportedOperationException` 错误

使用场景：设计线程安全类时候发布内部非线程安全的对象（前提是这个对象外界不需要修改，如果需要修改就老老实实使用JUC包下的对象）



实现原理（以Map为例子）：返回一个Collections的内部类UnmodefiableMap，里面包含了被private final修饰的刚传入的对象（保证对象可见性，同时避免对象逸出）

![image-20200401140559344](images/image-20200401140559344.png)

方法简单实现是通过将读方法直接调用内部封装的数据的方法，如果涉及到写，则直接抛出异常





## C：ConcurrentModificationException异常

ConcurrentModificationException（同时修改异常）



单线程条件下，以下代码很容易抛出这个异常（Javac会将for-each语法转换成为下面这个类）：

```java
Iterator<String> iterator = list.iterator();
while (iterator.hasNext()) {
  String next = iterator.next();
  if (Objects.equals(next, "hello")) {
    list.remove(next);
  }
}
System.out.println(list);
```

以List为例子，这些类会抛异常或出现一些奇怪的问题：`ArrayList，LinkedList，Collections.synchronizedList` （奇怪的问题就像：如果list里面存储的是`["hello","world"]`就不会报错，`["world","hello","hello"]`不会报错，但是下标为2的hello不会移除（最麻烦的情况，出了问题又不报错）），但使用`CopyOnWriteArrayList` 就不会报错，且情况正常。

> 《Java并发编程实战》中隐式的提出了上述问题的解决方案：替代方法就是“克隆”容器，并在副本上进行迭代，每个线程持有一个独立不发布的副本，也就是CopyOnWriteArrayList的实现思路



ConcurrentModificationException的抛出：

![image-20200401205921983](images/image-20200401205921983.png)

再进去

![image-20200401205939079](images/image-20200401205939079.png)



每次做next判断，都会进行比较，如果不一致则抛出这个异常

但是在多线程环境下可能没有保证List对象的可视性，导致数据滞留不同步



:question: 待续