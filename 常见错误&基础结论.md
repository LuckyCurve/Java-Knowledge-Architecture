

# 常见错误&结论

​																				C：结论，Q：问题，F：有趣的事儿

## C：如何读取当前类路径下的properties



简单例子

配置sso.properties：

```properties
url="hello world"
```



配置文件的读取：

```java
Properties properties = new Properties();
properties.load(this.getClass().getClassLoader().getResourceAsStream("sso.properties"));
String url = (String) properties.get("url");
System.out.println(url);
```

一定要读取到classLoader里面去，估计与类的运行机制有关





## Q：拦截器不生效的原因

写好的拦截器（实现HandlerInterceptor接口）一定要进行配置，才能起作用

拦截器：

```java
@Component
public class HelloHandler implements HandlerInterceptor {

    /**
     *  true：不拦截
     *  false：拦截在当前中
     */
    @Override
    public boolean preHandle(HttpServletRequest request, HttpServletResponse response, Object handler) throws Exception {
        System.out.println("拦截生效");
        return false;
    }
}
```

配置类：

```java
@Configuration
public class InterruptConfig implements WebMvcConfigurer {

    @Autowired
    HelloHandler helloHandler;

    @Override
    public void addInterceptors(InterceptorRegistry registry) {
        registry.addInterceptor(helloHandler).addPathPatterns("/**");
    }
}
```



## C：Java基本类型所占字节数

​	

|  类型   | 存储需求 |
| :-----: | :------: |
|  short  |    2     |
|   int   |    4     |
|  long   |    8     |
|  byte   |    1     |
|  float  |    4     |
| double  |    8     |
|  char   |    2     |
| boolean |    1     |
|         |          |



## C：JDBC的url书写规范

在MySQL8.0之后都要加上时区信息，否则会报错

```
jdbc:mysql://localhost:3306?serverTimezone=UTC
```



## C；数据库中的命名问题

数据库中命名表最好在后面加个s，避免一些不必要的麻烦，比如订单表order，就和MySQL的关键字冲突





## F：套娃式创建对象

在研究JUC的延迟初始化带来的问题的时候想到的

```java
public class Demo4 {

    Demo4 demo4;

    public static void main(String[] args) {
        Demo4 demo4 = new Demo4();
        System.out.println(ObjectSizeCalculator.getObjectSize(demo4));
    }
}
```

就是输出对象占的字节数，刚开始的时候代码是像上面那样写的，没报错，输出为16，删除成员变量之后输出还是16（对象头4字节，Class对象指针4字节，还有对其填充）

把上面代码修改了下，第三行改成`Demo4 demo4 = new Demo4();`

直接报错：

```java
Exception in thread "main" java.lang.StackOverflowError
	at cn.luckycurve.threadsecurity.Demo4.<init>(Demo4.java:7)
	at cn.luckycurve.threadsecurity.Demo4.<init>(Demo4.java:7)
	at cn.luckycurve.threadsecurity.Demo4.<init>(Demo4.java:7)
```

堆栈溢出错误（还蛮有意思的）

**C：仅仅在类中存在一个引用是不占内存的，初始外围对象的时候不会初始里面的对象，需要你手动去new**





## C：SpringBoot的并发性

SpringBoot默认实现了线程池，我们的异步调用就是通过启动线程池中的线程来完成的，具体体验如下

```java
    @GetMapping("/sleep")
    public String sleep() throws InterruptedException {
        System.out.println(Thread.currentThread().getName()+"：开始执行");
        TimeUnit.SECONDS.sleep(100);
        System.out.println(Thread.currentThread().getName()+"：执行完成");
        return "执行完成";
    }
```

同时开了五个窗口：

```java
http-nio-8080-exec-1：开始执行
http-nio-8080-exec-3：开始执行
http-nio-8080-exec-5：开始执行
http-nio-8080-exec-4：开始执行
http-nio-8080-exec-6：开始执行
http-nio-8080-exec-1：执行完成
http-nio-8080-exec-3：执行完成
http-nio-8080-exec-5：执行完成
http-nio-8080-exec-4：执行完成
http-nio-8080-exec-6：执行完成
```

明显的多线程任务





## C：Java数据传输

只有在基本数据类型和其封装类的是传值，在对象和基本数据类型数组都是传输的地址，所以只有基本数据类型需要get和set方法，对象只需要get方法





## C：谨慎操作数组

操作传入进来的数组默认就是操作原数据（传的是地址）

使用Arrays.copyOf()进行复制操作





## C：final修饰全局变量

final修饰全局变量不仅使得基本数据类型和其封装类无法改变数值，数组和类无法改变引用的对象，还保证了被修饰的变量的全局可见性，因此就有很多结论：

因为保证类的线程安全性只需要保证：1.操作的原子性，2.可见性

所以当类有如下关系，如果此时类B恰好还是线程安全的，则A可以将他的线程安全性交付给B

```java
Class A {
  private final Class B;
}
```

假设是如下的情况：则需要B，C线程安全并且BC之间没有耦合，可以推而广之

:warning:：这里的耦合关系不是指B，C的物理关系，而是逻辑关系，就像我们做缓存的时候用B做Key，C做Value，BC之间会相互依赖，即不满足这种条件

```java
Class A {
  private final Class B;
  private final Class C;
}
```

不用太纠结final变量的性能，final对性能的影响微乎其微，更何况我们编写程序的时候还是要以安全性优先的