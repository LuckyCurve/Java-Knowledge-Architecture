# Redis常见面试问题



Redis是一种运行在内存当中的非关系型数据库，使用c语言编写，由于他的高效读写能力，Redis通常用作缓存，分布式锁，分布式Session等场景

Redis原生还支持事务，持久化，集群方案等等。



在Redis之前，Memcached也经常拿来做缓存，只不过后来Memcached被淘汰了，两者的简单比较

相同点：

- 都是基于内存的数据库，一般都来作为缓存组件
- 两者的性能都非常优秀

不同点：

- Redis支持更加丰富的数据类型，除了Memcached仅仅支持的KV外，还支持list、set、zset、hash等数据结构
- Redis具有持久化特性，因此具有灾难恢复机制，Memcached没有（可用性）
- Redis可以将硬盘作为扩展存储当内存用完的时候使用，而Memcached会直接报错（扩展性）
- Redis原生支持集群方案，而Memcached需要在客户端内实现集群部署逻辑（可扩展性）
- Redis在6.0之前是单线程的多路IO复用模型，而Memcached是多线程，非阻塞的IO复用模型



数据缓存的一个处理流程：

用户查询Redis是否存在数据，如果存在直接返回

如果不存在，则访问数据库，如果数据库不存在则返回null

如果数据库存在，则更新Redis缓存并返回数据结果

经过这个流程的处理，系统并发量将不会直接被MySQL的并发上限所限制，增大了系统的吞吐量和响应时间。（高性能和高并发的角度）



Redis常见五大数据结构：

string数据结构，简单的kv类型，可以用于计数的场景，可以计算用户访问次数，文章访问量等等

```
127.0.0.1:6379> set number 1
OK
127.0.0.1:6379> incr number
(integer) 2
127.0.0.1:6379> get number
"2"
127.0.0.1:6379> decr number
(integer) 1
127.0.0.1:6379> get number
"1"
```



list数据结构，是使用双向链表链表实现的，为了支持反向查询，使用场景：消息队列

```
127.0.0.1:6379> rpush myList v1
(integer) 1
127.0.0.1:6379> rpush myList v2 v3
(integer) 3
127.0.0.1:6379> lpop myList
"v1"
127.0.0.1:6379> rpop myList
"v3"
```



hash：和HashMap类似，内部使用数组+链表实现，特别适合用于存储对象

```
127.0.0.1:6379> hset userInfo name LuckyCurve age 21
(integer) 2
127.0.0.1:6379> hget userInfo name
"LuckyCurve"
127.0.0.1:6379> hget userinfo age
(nil)
127.0.0.1:6379> hget userInfo age
"21"
127.0.0.1:6379> hset userInfo age 22
(integer) 0
127.0.0.1:6379> hget userInfo age
"22"
```



set：类似于Java中的HashSet，具有唯一性的特性，并且支持集合的交并补运算

```
127.0.0.1:6379> sadd mySet1 v1 v2
(integer) 2
127.0.0.1:6379> sadd mySet2 v2 v3
(integer) 2
127.0.0.1:6379> sinterstore mySet3 mySet1 mySet2
(integer) 1
127.0.0.1:6379> smembers mySet3
1) "v2"
```



zset：有序集合，类似于HashMap具有了TreeMap的排序功能一样，适用于对某些场景需要根据对象字段进行排序的情况





Redis是基于Reactor模型（反映模型模型，基于事件驱动）设计出来的，和Netty类似，Reactor好像成为了NIO开发的基石了，Redis的核心为文件事件处理器，因为文件事件处理器是单线程方式运行的，因此我们说Redis是单线程的。

这里的文件事件处理器非常类似于NIO当中的Selector组件，Selector是实现了对大量Channel的管理，这里的文件事件管理器同时监听大量的Socket，来并发处理大量请求

体现Redis具有反应式编程的特性在于：Redis是等待套接字执行请求，发送事件给文件事务管理器，文件事务管理器通过调用不同的事件处理器来完成响应



Redis之所以不愿意使用多线程，一直保持单线程到6.0是因为单线程容易维护，且不存在性能瓶颈，同时避免了上下文切换和锁竞争的消耗

Redis6.0之后引入多线程仅仅是针对较大的网络数据的读写上了，核心还是单线程



Redis可以设置过期时间来保证一些长时间没有被使用到的数据被清除，Redis的过期时间除了可以缓解内存压力，我们还可以利用过期这种特性来完成特定业务逻辑，如短信验证码60s之内有效



是使用一个hash数据结构【过期字典】来维持的过期时间，key指向一个数据，value存储的是key所指对象的过期时间



Redis过期数据的删除策略：

- 惰性删除：只有在取出key的时候才对数据进行过期检查，对CPU友好，对内存不利
- 定期删除：每隔一段时间根据过期字典删除一批数据，尽可能少影响CPU，对内存有利

Redis采取的是定期删除和惰性删除结合的策略，

【问题】：如果此时key比较多，惰性删除和定期删除可能漏掉大量的key，就需要使用到内存淘汰机制了。

内存淘汰机制不仅可以解决过期删除策略导致的key堆积问题主动淘汰一些key，还可以对热点数据进行筛选并保留，存在以下几种策略：

volatile-LRU：从过期字典中挑选最近使用最少的数据淘汰

volatile-TTL：从过期字典中挑选将要过期的数据进行淘汰

Randon：从过期字典中随机挑选数据进行淘汰

allkeys-lru：当内存不足时候，从过期字典中移除最少使用的数据【最常用】

allkeys-random：从数据集当中挑选任意数据淘汰

no-evictiion：禁止驱逐数据（用的非常少了）



Redis持久化机制

Redis有两种持久化方案，快照和只追加文件

快照相当于是某个时间点上内存数据的一个副本，可以将快照放在磁盘上等待下次的数据恢复，也可以直接将快照传给其他的数据库来实现Redis的主从复制结构，快照就是Redis默认的持久化方案，**不要感觉奇怪，因为Redis数据变换是非常频繁的，直接使用快照反而有时候有优势**

另一种持久化方案是只追加文件，类似于MySQL的redo log，直接在磁盘上记录更改Redis数据的命令。

4.0之后支持两个混合，但是默认依旧还是快照方式，混合之后就相当于基于某个版本的数据然后记录修改指令



Redis的事务，Redis的事务不同于传统的关系型数据库具有ACID特性，不支持事务回滚，因此不支持原子性和持久性，主要是为了性能考虑。Redis事务仅仅是提供命令打包功能，按顺序执行打包的所有操作，并且不会被中途打断。



使用Redis的两个常见问题：缓存穿透和缓存雪崩

缓存穿透：大量key不存在于Redis中，请求直接打到MySQL上了

布隆过滤器的核心就是一个byte数组，并且配合一系列的哈希函数进行扰动，对每个存在于MySQL中的元素，都会进行全部的哈希运算，得到多个哈希值，并将多个算出的哈希值置一。在查找的时候，也是同样的逻辑，将该元素进行哈希运算得到多个哈希值，判断这些哈希值对应的下标是否都为1，如果都为1则可能存在（主要存在一个哈希冲突，可以通过增大数组的容量和选择更优秀的哈希算法来解决），如果其中一个不为1则肯定不存在。

布隆过滤器的删除过程则比较复杂了。



缓存雪崩：主要指的是缓存数据大面积失效，导致请求直接打到了数据库上来，很可能导致数据库直接宕机

造成缓存大面积失效的原因可能是：Redis服务直接不可用、热点缓存数据突然失效

第一种解决方法：部署Redis集群，避免Redis服务宕机、限流，避免请求直接全部打到Redis上来

第二种解决方法：增加Redis所占内存，让内存中存取更多数据，从而导致缓存失效的比率降低。2、设置过期策略，设置成永不失效，防止一部分热点数据被丢弃





保证数据的一致性

无法做到短时间内的数据一致性，但是可以保证整体的数据一致性，即引入缓存的代价就是带来了短时间的数据不一致。

主要的解决策略为：更新DB的时候删除缓存，因为DB更新具有原子性，不用管，如果DB成功了但是cache删除失败了，建议定一个重试次数去一直重试。



通常，我们将保证数据一致性的策略叫做缓存读写策略，主要包括三种：

- 旁路缓存模式

适合读多写少的场景，也是最常用到的，读操作与上面说的一样，写操作则是先写DB，然后在删除cache。

为什么要先删除DB再删除cache呢？主要是因为cache的读写速度会比DB快的多，让DB先执行，cache后执行可以最大可能的减少数据不一致的时间。当然该方案只能减少数据不一致时候的时间，无法完全避免

缺陷：

1、首次请求的时候一定是不命中数据的

解决方法：预先加载一部分热数据进行预热

2、Redis和MySQL不具备强一致性

某个时间点仍然会存在Redis和MySQL数据不一致的问题，解决方法：使用分布式锁



- 读写穿透

运用的比较少，让应用直接和Redis打交道，Redis自身去做将数据写入DB的工作，这是非常少见的，因为Redis不支持将数据写入到DB当中

操作逻辑为：

读操作：从cache中获取数据，获取到了直接返回，如果获取不到，从DB加载到cache中，然后再由cache返回

写操作：先查cache，如果不存在则直接更新DB，如果存在则更新cache，然后cache自己去更新DB

缺陷：

1、首次请求数据必然不会命中缓存



- 异步缓存写入

感觉使用的更少了，是在读写穿透的基础上进行了改变，在数据更新的时候如果数据存储在cache中，读写穿透是cache同步调用DB去进行数据更新，而异步缓存写入则是只更新缓存，不直接更新DB，而是改为异步批量的方式更新DB、

可以看出写性能是非常高的，直接将数据改变完全写入到内存当中，适用于数据经常变化但是对数据一致性要求没那么高的场景。

缺陷：

1、首次访问数据必然不会出现在缓存

2、数据一致性可能比较差