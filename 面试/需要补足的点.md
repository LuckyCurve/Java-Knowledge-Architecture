十大[排序](https://www.nowcoder.com/jump/super-jump/word?word=排序)中的快排、归并、堆排，但是其实还有计数排序、桶排序和基数排序



堆排序：升序构造大顶推

如需要将数组array进行一个排序，假定array的长度为length，先对[0,length - 1]的数组，构造一个大顶堆，然后将下标为0的和下标为length - 1的数字进行交换，然后对[0,length - 2]的数组进行同样的重复操作，直到整个数组有序为止。

<hr>

计数排序：通过下标方式来进行实现

统计数组statistic当中的最大值和最小值，创建长度为max - min + 1长度的数组

数组的下标表示当前数值，数组的值表示统计个数

遍历原数组完成数组中元素个数的统计

最后根据统计数组的结果来对排序后的数组进行复原

非常适用于数据离散度较低的时候，空间复杂度为O（n+k），时间复杂度为O（n+k），稳定

<hr>

桶排序：计数排序的升级版，可以看成计数排序就是每个桶里面之存储相同元素，而桶排序当中的桶可以存放一定范围的元素

划分多个范围相同的子区间，每个子区间自排序，最后合并

因此需要保证数据均匀分布

> 如需要对0~100的数字进行排序
>
> 那么此时可以设定十个桶，桶分别表示从0~10、 11~20、 21~30的元素，直接将当前元素存入到对应的桶当中，先对桶内元素完成自排序，然后合并桶内的元素即可

基数排序，先创建10个桶来表示0~9

得到最高位数，先从个位数进行比较，根据最低位放入桶中进行计数排序

然后比较十位也重复这个操作，直到比较到最高位，排序完成后整个数组也就有序了

<hr>

这三种排序算法都利用了桶的概念，但对桶的使用方法上有明显差异：

- 基数排序：根据键值的每位数字来分配桶；
- 计数排序：每个桶只存储单一键值；
- 桶排序：每个桶存储一定范围的数值；



Linux下常用指令

目录相关: cd【进入目录】 mkdir【创建目录】 pwd【当前工作目录】 Is【列出简略的文件名信息】 ll=ls-l【详细信息包含时间 读写权限】 mv cp【文件复制、scp，远程传输，基于ssh并且数据加密了，上传jar包时候用】

> chmod 777 三个7表示的用户分别为：当前用户、当前用户组的用户、其他用户
>
> 7代表1（r）1（w）1（x）：可读可写可执行

文件相关: rm【删除文件】 cat【连接文件并输出到屏幕上，显示不够友好，使用more代替，空格下一页，b上一页】 tail【显示文件尾部、查看日志时候用nf】 head【查看头部 n】 vim【文件编辑】 find【文件查找，用的比较多的就是使用ant表达式来完成名字的匹配】

网络相关: ping【ICMP协议，判断是否可达】 ifconfig【显示网卡信息和IP地址】 netstat【显示连接信息，用的比较多的根据端口占用情况反查IP】

系统相关: reboot【重启】 shutdown【关机】 mount【挂载文件】 free【内存使用情况】 df【磁盘使用情况】

进程相关: top【进程资源占用情况】 ps【查看进程状态】 kill【杀死进程 -9 SIGKILL和-15 SIGKILL信号】



几种排序和时间复杂度

![img](https://img2018.cnblogs.com/blog/849589/201903/849589-20190306165258970-1789860540.png)

![img](https://images2018.cnblogs.com/blog/849589/201804/849589-20180402133438219-1946132192.png)



TCP TIME_WAIT状态

指的就是四次挥手的时候，A给B 发送FIN，B回ACK，B发FIN，A回ACK，如果A回ACK之后立马关闭了，那么此时B没有收到ACK确认，可能会以为丢包了，必然导致重复发送，然后就会接到A端的RST包（reset包 异常关闭），所以此时A不能立即关闭，进入TIME_WAIT状态，TIME_WAIT状态的开始与结束都主动由A方控制，持续时间为2MSL



HTTPS（连接建立过程，刚开始的TCP连接建立、主要是后来的TLS/SSL建立连接）

- 客户端发送ClientHello（协议版本、加密算法、随机数A）到服务端
- 服务端返回ServerHello（公钥、证书、随机数B）到客户端
- 客户端根据CA验证证书无误之后，生成随机数C，用公钥对其加密，发送到服务端
- 服务端用私钥解开获得随机数C，根据ClientHello当中指定的加密算法用随机数ABC生成对称密钥并使用其对数据进行加密
- 客户端此时也模拟这个过程来完成对对称密钥的获取和数据加密

这里证书是重中之重，证书是用来证明公钥拥有者身份的凭证

是这样完成的，申请者会使用非对称加密算法来获得一对公钥和私钥，然后将**需要的申请信息如（国家、域名等）连同公钥**【这里就是证书】发送给CA（证书认证机构），CA会使用消息摘要算法来完成对前面信息的摘要，并使用CA自己的私钥来完成对这个数据的加密，将这个加密后的数据【签名】添加到证书当中去。

因此在客户端拿到证书之后，可以使用相同的摘要算法来完成对当前证书信息的签名获取，与证书上的签名完成比对，如果签名是一致的就可以认为证书是可信任的。







笔试问题：

132

带跳跃移动的滑动窗口最大值

