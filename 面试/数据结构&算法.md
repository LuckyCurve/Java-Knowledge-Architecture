# 数据结构面试整理



主要是对常规数据结构的整理，需要补充红黑树、B+树、布隆过滤器



数组：使用一块连续的内存空间来存储，提供随机访问特性



链表：从属于线性表，但是离散的存储在内存空间当中的，在插入和删除操作上的复杂度为O（1），但是在查找节点或者访问指定位置的复杂度为O（n），对比数组，可以更充分的利用计算机的内存资源，但是空间利用率较低

可以通过节点之间持有的引用关系分为：单链表、循环链表（在单链表的基础上加上了last——>head）、双向链表（持有前后节点的引用）、双向循环链表（在双向链表的基础上连接了首尾）、



数组和链表的对比：

1、数组支持随机访问

2、数组对CPU的缓存机制更有好

3、如果有频繁的增删操作，数组可能需要扩容（通过复制数据的方式），但链表对频繁的增删天然友好



栈：具有LIFO的特性，在栈顶，支持pop操作和push操作，此外还有peek返回栈顶元素不出栈，只支持对栈顶的操作

> 可以用于解决括号匹配问题，字符串反转问题

Java中的栈是使用Vector实现的，amazing~



队列：具有FIFO特性，只允许从队尾入队，从队头出队，主要也有几种实现：单队列、循环队列

因为单队列会出现front前面无法利用的问题，因此引入了循环队列

> 实现有阻塞队列、运用于生产者消费者模型，线程池中的任务队列。



红黑树：算是对平衡二叉树的一种优化，平衡二叉树在极端情况下的时间复杂度为O（N）（所有节点都存放于右子树上，这样就退化成了链表）。为了解决这个问题，提出了红黑树的概念来进行改进，在每次进行增加节点和删除节点的时候都会进行树的一次平衡。



B+树：在数据库索引大量使用到了B树（也叫B-树）和B+树的数据结构

先记录B-树，在使用B-树时候需要给定阶数m，如5阶的B树

B树需要保证如下几条规则：

根节点的关键字数量（存储元素的个数）范围是：`[1, m - 1]`

非根节点的关键字数量范围是：`[m / 2, m - 1]`

节点中的关键字需要按顺序排列，每个关键字的左子树的所有关键字都小于他，右子树的所有关键字都大于它

如一个五阶的B树的插入：18、70、50、40、22、23、25、39

当插入到22的时候发现根节点大于m-1了，此时需要分裂，因为需要保证非根节点的数量至少为2，只有一种情况了：

![img](https://segmentfault.com/img/remote/1460000020416581)

![img](https://segmentfault.com/img/remote/1460000020416582)

因为B-树需要保证根节点到每个子节点的长度一致，保证最短的树高，因此会出现下面的转换

![img](https://segmentfault.com/img/remote/1460000020416584)

![img](https://segmentfault.com/img/remote/1460000020416585)

将左边的中间提到跟节点去，这时候保证划分出来的三个数据段都是以根节点的23和40作为分界点划分出来的。

上述的插入情况是相对直观的，下面的删除操作可能有几种情况：

- 叶子结点如果删除之后节点数量还是大于等于m/2，就直接删除即可
- 叶子结点如果删除之后节点数量小于m/2，就需要向兄弟节点借一个节点，通过公有的父节点来完成（其实B树就像是一个数据流，从左子树到根节点到右子树，如果此时左子树元素不够用的，将根节点元素挪到左子树，右子树挪一个元素顶替根节点即可）
- 非叶子节点删除是从右子树中挪动一个节点过去，然后再经过上述思想就行调整树大小



这是B树的数据结构，也叫B-树，下面介绍B+树

与B-树的结构非常类似，如根节点的元素个数为`[1, m - 1]`，非根节点的元素个数为`[m / 2, m - 1]`，不同点是非叶子节点仅仅只存放右子树的第一个元素的索引，因此也被称为 内部节点或者是索引节点，

![img](https://segmentfault.com/img/remote/1460000020416599)

感觉之所以要使用B+树就是因为在删除操作的时候仅仅涉及到兄弟元素的移动，然后对父节点直接进行修改，不用像是用B树一样去借一个父节点的元素了。



B+树较之于B树，MySQL之所以选择B+树作为索引的数据结构，主要是所有数据都存放在叶子结点上，数据更加集中，而不是像B树那样数据可以存放在非叶子节点上，这样可以更加好的利用CPU的缓存机制来减少磁盘的读写量



布隆过滤器，可以看成是数组和哈希函数两部分组成的数据结构，占用空间非常小，但是存在一个问题：可能产生误报，且随着元素增多，误报的几率越大

如果申请100 00000个大小的数组也才占用122kb的空间。

增加过程【需要注意多个哈希函数的处理】：

1、加入元素的时候，通过多个哈希函数算出多个哈希值

2、将每个哈希值的位置置1

删除过程：

1、给定元素进行多次哈希运算

2、判断数组中是否所有的位数都为1，如果都是1说明存在

![布隆过滤器hash计算](https://my-blog-to-use.oss-cn-beijing.aliyuncs.com/2019-11/布隆过滤器-hash运算.png)

> 如果返回元素存在，可能是误判，如果返回某个元素不存在，那么一定是正确地



使用场景：防止Redis缓存击穿



布隆过滤器在很多地方存在运用，如Guava对他进行了默认实现

自从Redis4.0开始支持插件，布隆过滤器RedisBloom就存在其中



