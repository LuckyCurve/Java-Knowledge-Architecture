# 算法（第四版）



> 对这本书的第一感官：满负赞誉的一本书，可我对一些经典书籍就是不感冒，不知道此书如何。希望通过这本书让我了解到数据存储到计算机的各种形式以及各种存储形式的利弊，带我一探JDK的数据结构实现，从而实现自己的知识体系，又或者是可以在实战中对现有通用的数据类型进行优化。





## 第一章、基础



对算法和数据结构给出的简要概念：

算法，即适合计算机实现的解决问题的方法，和算法关系最紧密的是数据结构，即便于算法操作的组织数据的方法。

本章就是介绍学习算法和数据结构所需要的基本工具

三种基本的数据类型：背包，队列和栈

算法存在的意义在于程序的高效运转。



Java数组的基本知识：

在对数组对象创建过程中（new关键字）需要指定数组长度，即其中可以包含的元素个数，而在声明的时候可以不用指定

即：`int[] a = new int[10];`，也可以回避掉new关键字，使用隐式创建的方式：`int[] ints = {1,2,3,4,5};`



在其中实现了二分查找算法：

```java
public class BinarySearch {

    /**
     * @param key 需要匹配的字符
     * @param a   搜索内容（有序）
     * @return 查询到的结果
     */
    public static Integer rank(Integer key, Integer[] a) {
        int low = 0;
        int high = a.length - 1;
        while (low <= high) {
            int middle = low + (high - low) / 2;
            if (key < a[middle]) {
                high = middle - 1;
            } else if (key > a[middle]) {
                low = middle + 1;
            } else {
                return middle;
            }
        }
        // 如果没有查询到，返回null
        return null;
    }


    /**
     * 测试
     */
    public static void main(String[] args) {
        Integer[] array = IntStream.rangeClosed(1, 10).boxed().toArray(Integer[]::new);
        System.out.println(rank(102, array));
    }
}
```

> 需要注意Integer[]和int[]之间的转换





在实现我们自己的抽象数据类型时候，我们应该关注数据本身并将实现对该数据的各种操作



所有的对象具有三大重要特征：状态，标识和行为。



使用主函数的参数`String[] args`

例如如下类：

```java
public class Test {

    public static void main(String[] args) {
        System.out.println(args[0]);
    }
}
```

使用如下命令：`java Test.java 10`于是输出10



Java提供额在程序运行时候检查程序状态的机制：

异常和断言。异常我们已经非常熟悉了，断言的基本用法如下：

```java
Integer a = 2;
assert a < 0 : "断言出错";
```

默认是关闭断言的，可以通过-ea参数来启用断言，这样在不匹配的位置就会抛出一个AssertionError（继承Error类）



Java引用的实现一种自然的实现方式就是使用指针，而另一种实现方式则使用的是句柄（指针的指针）。前者可以更快的访问数据，而后者则更容易垃圾回收





数据类型的值就是一组对象的集合，所有操作都是关于添加、删除或是访问集合中的对象。

现在我们了解三种这样的数据类型：背包、队列和栈。他们的不同之处仅仅在于删除或者访问对象的顺序不同

可以将背包理解成是一个不支持删除元素操作的集合数据类型，Java没有默认实现

队列是基于FIFO策略的集合类型

下压栈（简称栈）是基于LIFO策略的集合类型



创建泛型（T）数组不能直接使用`new T[size]`，这在Java语法中是不支持的，需要写成`(T[])new Object[size]`



ArrayList的扩容分析：

如果使用无参构造函数构建ArrayList，也是最常用的：

```java
public ArrayList() {
    this.elementData = DEFAULTCAPACITY_EMPTY_ELEMENTDATA;
}
```

会触发elementData的延迟初始化，在add方法中触发

```java
private void add(E e, Object[] elementData, int s) {
    if (s == elementData.length)
        elementData = grow();
    elementData[s] = e;
    size = s + 1;
}

public boolean add(E e) {
    modCount++;
    add(e, elementData, size);
    return true;
}
```

刚初始化完的ArrayList的elementData是空的，size也是0，于是触发了扩容

```java
private Object[] grow(int minCapacity) {
    return elementData = Arrays.copyOf(elementData,
                                       newCapacity(minCapacity));
}

private Object[] grow() {
    return grow(size + 1);
}
```

到底扩容到了多大呢？则需要newCapacity函数给出

```java
private int newCapacity(int minCapacity) {
    // overflow-conscious code
    int oldCapacity = elementData.length;
    int newCapacity = oldCapacity + (oldCapacity >> 1);
    if (newCapacity - minCapacity <= 0) {
        if (elementData == DEFAULTCAPACITY_EMPTY_ELEMENTDATA)
            return Math.max(DEFAULT_CAPACITY, minCapacity);
        if (minCapacity < 0) // overflow
            throw new OutOfMemoryError();
        return minCapacity;
    }
    return (newCapacity - MAX_ARRAY_SIZE <= 0)
        ? newCapacity
        : hugeCapacity(minCapacity);
}
```

这里的处理逻辑就十分明显了，只要不是越界的非零的整数，直接扩容1.5倍之后返回，之所以用位移运算符是源于该运算符的高效性。如果是0的话就直接赋值10了





顺便来看下LinkedList的插入元素机制（由于LinkedList使用的是双向链表存储结构，所以不会存在扩容的问题）

```java
transient int size = 0;

transient Node<E> first;

transient Node<E> last;
```

Node节点的摘要：

```java
private static class Node<E> {
    E item;
    Node<E> next;
    Node<E> prev;

    Node(Node<E> prev, E element, Node<E> next) {
        this.item = element;
        this.next = next;
        this.prev = prev;
    }
}
```

典型的双向链表存储结构



基本上和ArrayList一样，初始化啥都不干

```java
public LinkedList() {
}
```

添加元素的逻辑也是比较简单的

```java
void linkLast(E e) {
    final Node<E> l = last;
    final Node<E> newNode = new Node<>(l, e, null);
    last = newNode;
    if (l == null)
        first = newNode;
    else
        l.next = newNode;
    size++;
    modCount++;
}
```

采取的是尾插法，且当第一次插入的时候，会将first和last同时都置为包含该元素的Node，并且其前后节点都为空，当有多条数据时候，first的前置节点仍然为null，last的后置节也为null。经典的双联表结构

> 当然LinkedList的精华不在添加数据这一块儿，而是在查询数据这一块儿，而ArrayList的重头戏便是添加数据进行扩容



既然Vector和ArrayList如此之像，看看Vector的扩容机制与ArrayList的区别：

在创建Vector的时候就完成了初始化工作，默认大小是10，并且在初始化的时候支持传入一个增量，如果没有的话那就是0。

接下来是扩容大小：

```java
private int newCapacity(int minCapacity) {
    // overflow-conscious code
    int oldCapacity = elementData.length;
    int newCapacity = oldCapacity + ((capacityIncrement > 0) ?
                                     capacityIncrement : oldCapacity);
    if (newCapacity - minCapacity <= 0) {
        if (minCapacity < 0) // overflow
            throw new OutOfMemoryError();
        return minCapacity;
    }
    return (newCapacity - MAX_ARRAY_SIZE <= 0)
        ? newCapacity
        : hugeCapacity(minCapacity);
}
```

这里可以看到，如果没有指定增量capacityIncrement，也就是当其为0的时候，便会出现双倍的扩容，并且也没有对其进行优化。



在删除元素的时候并不会发生缩容



手动实现栈结构：

```java
/**
 * @author LuckyCurve
 * @date 2020/9/2 9:02
 * 下压栈的实现
 */
public class ResizingArrayStack<Item> implements Iterable<Item> {

    /**
     * 栈的元素个数
     */
    private Integer num = 0;

    /**
     * 存储元素，需要初始化为2，不然的话扩容完全
     */
    private Item[] elementData = (Item[]) new Object[2];

    /**
     * 判空
     */
    public Boolean isEmpty() {
        return num == 0;
    }

    /**
     * 获取栈元素个数
     */
    public Integer size() {
        return num;
    }

    /**
     * 入栈
     */
    public void push(Item item) {
        // 判断是否栈满了
        if (num == elementData.length) {
            // 发生扩容操作，使用类似于ArrayList的扩容机制

            resize(elementData.length + (elementData.length >> 1));
        }

        elementData[num++] = item;
    }

    /**
     * 出栈
     */
    public void pop() {
        // 直接弹出元素
        Item result = elementData[--num];
        // 解除引用关系，使其满足垃圾回收条件
        elementData[num] = null;

        // 判断是否需要缩容，这里判断要求大于零是为了防止栈空的时候也满足条件发生缩容
        if (num > 0 && num == elementData.length / 4) {
            resize(elementData.length / 2);
        }
    }


    /**
     * 调整栈的大小
     */
    private void resize(Integer max) {
        // 输出
        System.out.println("发生扩容：" + max);
        // 原数据
        Item[] src = elementData;
        elementData = (Item[]) new Object[max];

        // 赋值操作
        for (int i = 0; i < src.length; i++) {
            elementData[i] = src[i];
        }
    }

    /**
     * 迭代器
     */
    @Override
    public Iterator<Item> iterator() {
        return new Iterator<Item>() {

            // 维持内部引用
            private Integer temp = num;

            @Override
            public boolean hasNext() {
                return temp > 0;
            }

            @Override
            public Item next() {
                return elementData[--temp];
            }
        };
    }

    /**
     * 测试代码
     */
    public static void main(String[] args) {
        ResizingArrayStack<String> stack = new ResizingArrayStack<>();
        for (int i = 0; i < 100; i++) {
            System.out.println("插入元素：" + (i + 1));
            stack.push(String.valueOf(i + 1));
        }
    }
}
```

关注第四十行代码，其中借鉴了ArrayList的扩容机制，但是在第一次没有加上括号于是频繁出错，是算数优先级的问题导致的：



| 优先级 | 运算符                                           | 结合性   |
| ------ | ------------------------------------------------ | -------- |
| 1      | ()、[]、{}                                       | 从左向右 |
| 2      | !、+、-、~、++、--                               | 从右向左 |
| 3      | *、/、%                                          | 从左向右 |
| 4      | +、-                                             | 从左向右 |
| 5      | «、»、>>>                                        | 从左向右 |
| 6      | <、<=、>、>=、instanceof                         | 从左向右 |
| 7      | ==、!=                                           | 从左向右 |
| 8      | &                                                | 从左向右 |
| 9      | ^                                                | 从左向右 |
| 10     | \|                                               | 从左向右 |
| 11     | &&                                               | 从左向右 |
| 12     | \|\|                                             | 从左向右 |
| 13     | ?:                                               | 从右向左 |
| 14     | =、+=、-=、*=、/=、&=、\|=、^=、~=、«=、»=、>>>= | 从右向左 |

可以看到位移运算的运算优先级是低于加减运算的。





在遍历链表的时候，使用如下语句就和使用forEach循环一样正常：

```java
for (Node x = first;x != null;x = x.next) {
    // do Something
}
```



上面是使用数组作为数据存放的一个容器，现在可以使用链表这种存储结构来存储数据，这里的链表指的是单向链表（比较基础的）