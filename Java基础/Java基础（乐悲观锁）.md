## Java乐观锁和悲观锁



乐观锁和悲观锁对应着生活中人们将事情往好的方向或者坏的方向去想



乐观锁：总是假设最好的情况，在拿数据的时候认为别人不会修改，所以不会上锁，但是在更新数据的时候会去判断在此期间是否有其他线程也在更新数据，通过版本号机制和CAS算法实现。**乐观锁适用于多读的类型，因为读取操作不会上锁，可以提高吞吐量**，类似于数据库的**write_condition**机制，在java.util.concurrent.atomic包下的的原子变量类使用了CAS去实现的



悲观锁：总是假设最坏的情况，在拿数据的是否认为别人会修改，所以会上锁，写入的时候也会上锁，即获取当前资源的锁，阻塞其他线程，数据库中就有行锁，表锁，读锁，写锁等等，在Java中也有synchronized和ReentrantLock等独占锁就是悲观锁的思想





## 应用场景

一般写入少的使用乐观锁，冲突会比较少，省去了锁的开销，加大了系统的吞吐量，但是一旦写入操作多了起来，必然会导致经常产生冲突，乐观锁机制中每次产生冲突就会重置任务，导致造成更大的开销，所以如果是多写入的情况一般用悲观所









## 乐观锁的具体实现方式

> 一般使用版本号机制和CAS算法来实现的



1.版本号机制：

会为数据加上一个version字段，更新数据完成的时候，会自动将version+1，当线程读取数据的时候，会顺便读取version字段，在提交更新时，如果version相同则执行更新操作，否则重试更新操作。





2.CAS算法

CAS（**compare and swap** ）（比较与交换），是一种有名的无锁算法，在没有线程阻塞的情况下实现多线程之间的变量同步，所以也叫非阻塞同步

CAS算法涉及到三个操作数：

- 需要读写的内存值V
- 进行比较的值A
- 拟写入的新值B

有且仅当V的值等于A时，CAS通过原子方式用新值B来更新V的值，一般情况下是一个自旋操作，即不断的重试





## 乐观锁的缺点



CAS：ABA问题：

通过CAS只能判断数据在时间段首和时间段末的值是否相等来，来判断线程中变量是否在这个时间段内同步，如果在时间段中间某一时间变成了B，在最后又变成了A，则CAS无法判断





通病：循环时间长开销大：

如果一个操作一直不能执行成功，乐观锁机制会让他一直的进行重试，会给CPU造成大量的CPU开销





CAS：只能保证一个共享变量的原子操作

如果有多个共享变量时候CAS就无效了，但是可以将多个共享变量合并成为一个共享变量来使用

