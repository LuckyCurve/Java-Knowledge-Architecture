# 序



设计模式（GOF23：Gang of Four，编写《设计模式》的四位大佬的统称）的引入：主要是由一本书《Design Patterns：Elements of Reusable Object Oriented Software》，中文译名为《设计模式——可复用面向对象软件的基础》，可见，设计模式是建立在面向对象编程模型之上的，可以理解为是面向对象的高级使用方法，前人已经对其进行了总结。因此，本书主要是围绕着面向对象编程思想和23种设计模式展开的。

作者对本书的定义：一本通过故事讲述程序如何设计的方法集，本书希望能给渴望了解OO世界的初学者、困惑于僵硬，脆弱，无法复用的代码编程体验者、一直打着OO编程的旗号，做着过程式开发的基于对象的编程实践者一些好的建议和提示。争取理解其中设计模式的迭代与改进过程，在以后自己编写面向对象程序时候进行运用。

这本书吸引我的地方：在不断的提问与回答过程中，在程序的不断重构演变中，把设计模式的门槛降低，而不是直接给出一个趋近于完美的答案。

本书分为4个部分：

1、面向对象的意义与好处以及几个重要的设计原则（很有必要，因为设计模式是简历在OO之上的，意义了解更为重要，因为现在好像都在推崇函数式编程，让我有点迷惑，看这部分的时候可以带着这几个问题去看）

2、详细讲解23个设计模式

3、对设计模式的总结，相互之间的比较

4、附录：针对面向对象概念的补充，如：类、封装、继承、多态、接口、事件等

设计模式其实发展至今远不止23种，但是在学习GOF总结的23种设计模式应该是可以学习到很多东西的，像是别人自己总结了编程经验并直接传授给你，这种感受是非常好的，当然还是需要与自己的编程过程相呼应，要不就是对牛弹琴，无法产生共鸣了。





# 第一章、代码无错便是优？——简单工厂模式



作者的文笔真的非常好，看的蛮有意思的，或许是前面讲述的东西以前了解过，所以感觉非常轻松。

第一阶段代码：

```java
/**
 * @author LuckyCurve
 * @date 2021/1/8 17:08
 * 实现计算器功能，两个数的四则运算
 */
public class Operation1 {
    public static void main(String[] args) {
        Scanner scanner = new Scanner(System.in);
        String info = scanner.nextLine();
        int num1 = Integer.parseInt(info.substring(0, 1));
        String oper = info.substring(1, 2);
        int num2 = Integer.parseInt(info.substring(2, 3));

        switch (oper) {
            case "+":
                System.out.println(num1 + num2);
                break;
            case "-":
                System.out.println(num1 - num2);
                break;
            case "*":
                System.out.println(num1 * num2);
                break;
            case "/":
                System.out.println(num1 / num2);
                break;
            default:
                System.out.println("error:Operation Not Found");
        }
    }
}
```

主要就是将业务和界面分离开来，即OO三大特性中的封装性，让下次使用的时候可以选择是代码复用（对函数的调用）而不是简单的代码复制（Ctrl C）了

第二阶段代码：

```java
/**
 * @author LuckyCurve
 * @date 2021/1/8 17:18
 * 实现业务与界面的分离
 */
public class Operation2 {
    public static void main(String[] args) {
        Scanner scanner = new Scanner(System.in);
        String info = scanner.nextLine();
        int num1 = Integer.parseInt(info.substring(0, 1));
        String oper = info.substring(1, 2);
        int num2 = Integer.parseInt(info.substring(2, 3));
        System.out.println(Operation.getResult(num1, oper, num2));
    }

    static class Operation {
        public static Integer getResult(Integer num1, String oper, Integer num2) {
            switch (oper) {
                case "+":
                    return num1 + num2;
                case "-":
                    return num1 - num2;
                case "*":
                    return num1 * num2;
                case "/":
                    return num1 / num2;
                default:
                    throw new IllegalArgumentException("error:Operation Not Found");
            }
        }
    }
}
```

但是一旦需要添加一个运算方法，如开方运算，则需要重新去修改代码，在修改过程中可能存在将以前代码改变的情况（如果这是一个算员工工资的系统，有些员工就可以改变计算过程从而改变自身的工资了），因此，更正确地操作是使用继承，创建一个计算接口，分别实现加减乘除类分别实现这个接口，重写其中的getResult方法即可。这就是继承的具体应用，至于到底该使用哪个子类，我们可以通过工厂来实现。

第三阶段代码：

```java
/**
 * @author LuckyCurve
 * @date 2021/1/8 17:24
 * 实现OO的继承特性
 */
public class Operation3 {
    public static void main(String[] args) {
        Scanner scanner = new Scanner(System.in);
        String info = scanner.nextLine();
        int num1 = Integer.parseInt(info.substring(0, 1));
        String oper = info.substring(1, 2);
        int num2 = Integer.parseInt(info.substring(2, 3));

        Operation operate = OperationFactory.createOperate(oper);
        System.out.println(operate.getResult(num1, num2));
    }

}

/**
 * 创建Operation对象工厂，具体创建哪个类的对象由该工厂给定
 */
class OperationFactory {

    public static Operation createOperate(String operate) {
        switch (operate) {
            case "+":
                return new OperationAdd();
            case "-":
                return new OperationSub();
            case "*":
                return new OperationMul();
            case "/":
                return new OperationDiv();
            default:
                throw new IllegalArgumentException("error:Operation not Found");
        }
    }
}

interface Operation {

    Integer getResult(Integer num1, Integer num2);
}

class OperationAdd implements Operation {

    @Override
    public Integer getResult(Integer num1, Integer num2) {
        return num1 + num2;
    }
}

class OperationSub implements Operation {

    @Override
    public Integer getResult(Integer num1, Integer num2) {
        return num1 - num2;
    }
}

class OperationMul implements Operation {

    @Override
    public Integer getResult(Integer num1, Integer num2) {
        return num1 * num2;
    }
}

class OperationDiv implements Operation {

    @Override
    public Integer getResult(Integer num1, Integer num2) {
        return num1 / num2;
    }
}

```

这里就简单使用到了工厂模式这种设计模式，当然在编写的时候难免感觉有些拖沓，但在使用的时候体验是真的棒。



画出上面的UML类图，方便分析

> 继承关系：
>
> ![image-20210108212821762](images/image-20210108212821762.png)
>
> 实现接口：
>
> ![image-20210108212910187](images/image-20210108212910187.png)
>
> 关联：
>
> ![image-20210108212935545](images/image-20210108212935545.png)
>
> > Code：
> >
> > ```java
> > class 企鹅 {
> >     private 气候 气候;
> > }
> > ```
>
> 聚合关系：
>
> ![image-20210108213101557](images/image-20210108213101557.png)
>
> > Code：
> >
> > ```java
> > class 雁群 {
> >     private 大雁[] 大雁;
> > }
> > ```
>
> 合成（组合）关系：
>
> ![image-20210108213234272](images/image-20210108213234272.png)
>
> 与关联关系非常类似，但是这个关系的生命周期是相同的
>
> > Code：
> >
> > ```java
> > class 鸟 {
> >     private 翅膀 翅膀;
> >     public 鸟() {
> >         翅膀 = new 翅膀();
> >     }
> > }
> > ```
>
> 依赖关系：
>
> ![image-20210108213535548](images/image-20210108213535548.png)
>
> > Code：
> >
> > ```java
> > class 动物 {
> >     public void 新陈代谢(氧气 氧气,水 水);
> > }
> > ```
> >
> > 可以认为是方法的输入



![image-20210108213700077](images/image-20210108213700077.png)