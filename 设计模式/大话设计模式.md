# 序



设计模式（GOF23：Gang of Four，编写《设计模式》的四位大佬的统称）的引入：主要是由一本书《Design Patterns：Elements of Reusable Object Oriented Software》，中文译名为《设计模式——可复用面向对象软件的基础》，可见，设计模式是建立在面向对象编程模型之上的，可以理解为是面向对象的高级使用方法，前人已经对其进行了总结。因此，本书主要是围绕着面向对象编程思想和23种设计模式展开的。

作者对本书的定义：一本通过故事讲述程序如何设计的方法集，本书希望能给渴望了解OO世界的初学者、困惑于僵硬，脆弱，无法复用的代码编程体验者、一直打着OO编程的旗号，做着过程式开发的基于对象的编程实践者一些好的建议和提示。争取理解其中设计模式的迭代与改进过程，在以后自己编写面向对象程序时候进行运用。

这本书吸引我的地方：在不断的提问与回答过程中，在程序的不断重构演变中，把设计模式的门槛降低，而不是直接给出一个趋近于完美的答案。

本书分为4个部分：

1、面向对象的意义与好处以及几个重要的设计原则（很有必要，因为设计模式是简历在OO之上的，意义了解更为重要，因为现在好像都在推崇函数式编程，让我有点迷惑，看这部分的时候可以带着这几个问题去看）

2、详细讲解23个设计模式

3、对设计模式的总结，相互之间的比较

4、附录：针对面向对象概念的补充，如：类、封装、继承、多态、接口、事件等

设计模式其实发展至今远不止23种，但是在学习GOF总结的23种设计模式应该是可以学习到很多东西的，像是别人自己总结了编程经验并直接传授给你，这种感受是非常好的，当然还是需要与自己的编程过程相呼应，要不就是对牛弹琴，无法产生共鸣了。





# 第一章、代码无错便是优？——简单工厂模式



作者的文笔真的非常好，看的蛮有意思的，或许是前面讲述的东西以前了解过，所以感觉非常轻松。

第一阶段代码：

```java
/**
 * @author LuckyCurve
 * @date 2021/1/8 17:08
 * 实现计算器功能，两个数的四则运算
 */
public class Operation1 {
    public static void main(String[] args) {
        Scanner scanner = new Scanner(System.in);
        String info = scanner.nextLine();
        int num1 = Integer.parseInt(info.substring(0, 1));
        String oper = info.substring(1, 2);
        int num2 = Integer.parseInt(info.substring(2, 3));

        switch (oper) {
            case "+":
                System.out.println(num1 + num2);
                break;
            case "-":
                System.out.println(num1 - num2);
                break;
            case "*":
                System.out.println(num1 * num2);
                break;
            case "/":
                System.out.println(num1 / num2);
                break;
            default:
                System.out.println("error:Operation Not Found");
        }
    }
}
```

主要就是将业务和界面分离开来，即OO三大特性中的封装性，让下次使用的时候可以选择是代码复用（对函数的调用）而不是简单的代码复制（Ctrl C）了

第二阶段代码：

```java
/**
 * @author LuckyCurve
 * @date 2021/1/8 17:18
 * 实现业务与界面的分离
 */
public class Operation2 {
    public static void main(String[] args) {
        Scanner scanner = new Scanner(System.in);
        String info = scanner.nextLine();
        int num1 = Integer.parseInt(info.substring(0, 1));
        String oper = info.substring(1, 2);
        int num2 = Integer.parseInt(info.substring(2, 3));
        System.out.println(Operation.getResult(num1, oper, num2));
    }

    static class Operation {
        public static Integer getResult(Integer num1, String oper, Integer num2) {
            switch (oper) {
                case "+":
                    return num1 + num2;
                case "-":
                    return num1 - num2;
                case "*":
                    return num1 * num2;
                case "/":
                    return num1 / num2;
                default:
                    throw new IllegalArgumentException("error:Operation Not Found");
            }
        }
    }
}
```

但是一旦需要添加一个运算方法，如开方运算，则需要重新去修改代码，在修改过程中可能存在将以前代码改变的情况（如果这是一个算员工工资的系统，有些员工就可以改变计算过程从而改变自身的工资了），因此，更正确地操作是使用继承，创建一个计算接口，分别实现加减乘除类分别实现这个接口，重写其中的getResult方法即可。这就是继承的具体应用，至于到底该使用哪个子类，我们可以通过工厂来实现。

第三阶段代码：

```java
/**
 * @author LuckyCurve
 * @date 2021/1/8 17:24
 * 实现OO的继承特性
 */
public class Operation3 {
    public static void main(String[] args) {
        Scanner scanner = new Scanner(System.in);
        String info = scanner.nextLine();
        int num1 = Integer.parseInt(info.substring(0, 1));
        String oper = info.substring(1, 2);
        int num2 = Integer.parseInt(info.substring(2, 3));

        Operation operate = OperationFactory.createOperate(oper);
        System.out.println(operate.getResult(num1, num2));
    }

}

/**
 * 创建Operation对象工厂，具体创建哪个类的对象由该工厂给定
 */
class OperationFactory {

    public static Operation createOperate(String operate) {
        switch (operate) {
            case "+":
                return new OperationAdd();
            case "-":
                return new OperationSub();
            case "*":
                return new OperationMul();
            case "/":
                return new OperationDiv();
            default:
                throw new IllegalArgumentException("error:Operation not Found");
        }
    }
}

interface Operation {

    Integer getResult(Integer num1, Integer num2);
}

class OperationAdd implements Operation {

    @Override
    public Integer getResult(Integer num1, Integer num2) {
        return num1 + num2;
    }
}

class OperationSub implements Operation {

    @Override
    public Integer getResult(Integer num1, Integer num2) {
        return num1 - num2;
    }
}

class OperationMul implements Operation {

    @Override
    public Integer getResult(Integer num1, Integer num2) {
        return num1 * num2;
    }
}

class OperationDiv implements Operation {

    @Override
    public Integer getResult(Integer num1, Integer num2) {
        return num1 / num2;
    }
}

```

这里就简单使用到了工厂模式这种设计模式，当然在编写的时候难免感觉有些拖沓，但在使用的时候体验是真的棒。



画出上面的UML类图，方便分析

> 继承关系：
>
> ![image-20210108212821762](images/image-20210108212821762.png)
>
> 实现接口：
>
> ![image-20210108212910187](images/image-20210108212910187.png)
>
> 关联：
>
> ![image-20210108212935545](images/image-20210108212935545.png)
>
> > Code：
> >
> > ```java
> > class 企鹅 {
> >     private 气候 气候;
> > }
> > ```
>
> 聚合关系：
>
> ![image-20210108213101557](images/image-20210108213101557.png)
>
> > Code：
> >
> > ```java
> > class 雁群 {
> >     private 大雁[] 大雁;
> > }
> > ```
>
> 合成（组合）关系：
>
> ![image-20210108213234272](images/image-20210108213234272.png)
>
> 与关联关系非常类似，但是这个关系的生命周期是相同的
>
> > Code：
> >
> > ```java
> > class 鸟 {
> >     private 翅膀 翅膀;
> >     public 鸟() {
> >         翅膀 = new 翅膀();
> >     }
> > }
> > ```
>
> 依赖关系：
>
> ![image-20210108213535548](images/image-20210108213535548.png)
>
> > Code：
> >
> > ```java
> > class 动物 {
> >     public void 新陈代谢(氧气 氧气,水 水);
> > }
> > ```
> >
> > 可以认为是方法的输入



![image-20210108213700077](images/image-20210108213700077.png)





# 第二章、商场促销——策略模式



实现商品促销，主要的促销方式有：不打折、打几折、满多少减多少。

由于上述情况都有可能出现，因此使用工厂模式来做，但是出现了一个问题：入参个数和类型不同，那么应该怎么样进行抽象呢。

> 在子类的内部维护对象成员，从而实现方法的入参和出参都相同。
>
> 有两种注入方法：构造器注入和Set注入，这里优先应该选择构造器注入，使得组成合成关系（同生共死）

代码：

```java
/**
 * @author LuckyCurve
 * @date 2021/1/9 9:28
 * 实现收费，工厂方式
 */
public class Cash {
    public static void main(String[] args) {
        CashSuper cash = CashFactory.createCashAccept("满300减100");
        System.out.println(cash.acceptCash(500.0));
    }
}

class CashFactory {
    public static CashSuper createCashAccept(String type) {
        switch (type) {
            case "正常收费":
                return new CashNormal();
            case "打8折":
                return new CashRebate(0.8);
            case "满300减100":
                return new CashReturn(300.0, 100.0);
            default:
                throw new IllegalArgumentException("error:Type Not Found");
        }
    }
}

interface CashSuper {
    /**
     * 收取现金的方法
     */
    Double acceptCash(Double money);
}

class CashNormal implements CashSuper {

    @Override
    public Double acceptCash(Double money) {
        return money;
    }
}

/**
 * 打折
 */
class CashRebate implements CashSuper {

    private Double moneyRebate;

    public CashRebate(Double moneyRebate) {
        this.moneyRebate = moneyRebate;
    }

    @Override
    public Double acceptCash(Double money) {
        return money * moneyRebate;
    }
}

/**
 * 满减
 */
class CashReturn implements CashSuper {

    private Double moneyCondition;

    private Double moneyReturn;

    public CashReturn(Double moneyCondition, Double moneyReturn) {
        this.moneyCondition = moneyCondition;
        this.moneyReturn = moneyReturn;
    }

    @Override
    public Double acceptCash(Double money) {
        if (money >= moneyCondition) {
            money -= moneyReturn * (int) (money / moneyCondition);
        }
        return money;
    }
}
```



虽然推出了新的打折活动，程序只需要简单继承CashSuper，然后去收费对象生成工厂里面加上这种判断条件就行了。

> 面对算法的时常变动，应该有更好的办法，就是策略模式



策略模式：定义了算法家族，分别封装起来，让它们之间可以相互替换，此模式让算法的变化，不会影响到使用算法的客户。

策略模式的UML图：

![image-20210109183422576](images/image-20210109183422576.png)

感觉策略模式和工厂模式非常的像，使用策略模式实现商场促销的代码如下：

```java
/**
 * @author LuckyCurve
 * @date 2021/1/9 18:39
 * 更好的是使用策略模式来实现，直接使用前面的类和接口原型即可
 */
public class Cash2 {
    public static void main(String[] args) {
        // 选择满减策略测试
        CashContext context = new CashContext(new CashReturn(100.0, 30.0));
        System.out.println(context.getResult(200.0));
    }
}

/**
 * 从工厂改成了Context
 */
class CashContext {
    private CashSuper cashSuper;

    public CashContext(CashSuper cashSuper) {
        this.cashSuper = cashSuper;
    }

    Double getResult(Double money) {
        return cashSuper.acceptCash(money);
    }
}
```

此时存在一个弊端，判断逻辑需要在主函数里面写出来，当然感觉这影响不是很大，改进方法是结合工厂模式：

```java
/**
 * @author LuckyCurve
 * @date 2021/1/9 19:07
 * 策略模式结合工厂模式
 */
public class Cash3 {
    public static void main(String[] args) {
        CashContext2 context = new CashContext2("满300减100");
        System.out.println(context.getResult(500.0));
    }
}

/**
 * 策略模式结合工厂模式，将判断逻辑进一步内移
 */
class CashContext2 {
    private CashSuper cashSuper;

    public CashContext2(String type) {
        switch (type) {
            case "正常收费":
                cashSuper = new CashNormal();
                break;
            case "打8折":
                cashSuper = new CashRebate(0.8);
                break;
            case "满300减100":
                cashSuper = new CashReturn(300.0,100.0);
                break;
            default:
                throw new IllegalArgumentException("error:Type Not Found");
        }
    }

    public Double getResult(Double money) {
        return cashSuper.acceptCash(money);
    }
}
```

当这样优化之后，主函数（可以理解成客户端）对代码的调用就只有涉及到了CashContext对象了

感觉如果只有一个方法需要重写，使用策略模式是远好于工厂方法的，说白了，工厂方法返回对象，策略模式返回函数，但是在Java8之前不涉及函数。





# 第三章、拍摄UFO——单一职责原则



> 故事真的蛮有意思，由衷感叹一句作者不做老师可惜了。



讲述了使用手机拍摄和数码相机拍摄的差距，由于手机集成了太多其他功能导致拍摄效果非常差，从而引出单一职职责原则。

大多数时候，一件产品简单一些，职责单一一些，或许是更好的选择。这就和设计模式中的一大原则——单一职责的道理是一样的。

单一职责原则：就一个类而言，应该仅有一个引起他变化的原因。

> 说人话，就是如果需要你设计一个窗口程序，不要将运算、数据库访问、页面展示都塞在这一个类里面，这会导致维护麻烦，基本上无法复用，缺乏灵活性。



如果要开发一个俄罗斯方块的游戏，应该尽量将游戏逻辑如：下落、旋转、碰撞检测单独拿出来写一个类，这样在如果需要将项目移动到手机端，这些游戏逻辑都是可以直接重用的。

如果一个类承担的职责过多，就等于把这些职责耦合在一起，一个职责的变化可能会削弱或者抑制这个类完成其他职责的能力。这种耦合会导致脆弱的设计，当变化发生时，设计会遭到意想不到的破坏。



